syntax = "proto3";

package ibc.core.channel.v1;

option go_package = "github.com/cosmos/ibc-go/v8/modules/core/04-channel/types";

import "gogoproto/gogo.proto";
import "ibc/core/client/v1/client.proto";

// Packet defines a type that carries data across different chains through IBC
message Packet {
  option (gogoproto.goproto_getters) = false;

  // number corresponds to the order of sends and receives, where a Packet
  // with an earlier sequence number must be sent and received before a Packet
  // with a later sequence number.
  uint64 sequence = 1;
  // identifies the port on the sending chain.
  string source_port = 2;
  // identifies the channel end on the sending chain.
  string source_channel = 3;
  // identifies the port on the receiving chain.
  string destination_port = 4;
  // identifies the channel end on the receiving chain.
  string destination_channel = 5;
  // actual opaque bytes transferred directly to the application module
  bytes data = 6;
  // block height after which the packet times out
  ibc.core.client.v1.Height timeout_height = 7 [(gogoproto.nullable) = false];
  // block timestamp (in nanoseconds) after which the packet times out
  uint64 timeout_timestamp = 8;
}

// PacketState defines the generic type necessary to retrieve and store
// packet commitments, acknowledgements, and receipts.
// Caller is responsible for knowing the context necessary to interpret this
// state as a commitment, acknowledgement, or a receipt.
message PacketState {
  option (gogoproto.goproto_getters) = false;

  // channel port identifier.
  string port_id = 1;
  // channel unique identifier.
  string channel_id = 2;
  // packet sequence.
  uint64 sequence = 3;
  // embedded data that represents packet state.
  bytes data = 4;
}

// PacketId is an identifier for a unique Packet
// Source chains refer to packets by source port/channel
// Destination chains refer to packets by destination port/channel
message PacketId {
  option (gogoproto.goproto_getters) = false;

  // channel port identifier
  string port_id = 1;
  // channel unique identifier
  string channel_id = 2;
  // packet sequence
  uint64 sequence = 3;
}

// PacketData is the recommended packet data format to be used for sending packets
// this allows the IBC router to execute multiple IBC applications for a single packet
// with versioned isolated data. This enables atomic execution of multiple IBC applications
// along with simpler upgrade paths for applications
message PacketData {
  repeated AppData app_data = 1;
}

// AppData is the recommended format for application-specific data to be sent in an IBC packet
// the application data includes the port identifier along with the requested version
// so that the IBC router can route this data to the requested application with the requested version
message AppData {
  string port_id = 1;
  string version = 2;
  bytes  data    = 3;
}

// Acknowledgement is the recommended acknowledgement format to be used by
// app-specific protocols.
// NOTE: The field numbers 21 and 22 were explicitly chosen to avoid accidental
// conflicts with other protobuf message formats used for acknowledgements.
// The first byte of any message with this format will be the non-ASCII values
// `0xaa` (result) or `0xb2` (error). Implemented as defined by ICS:
// https://github.com/cosmos/ibc/tree/master/spec/core/ics-004-channel-and-packet-semantics#acknowledgement-envelope
message Acknowledgement {
  // response contains either a result or an error and must be non-empty
  oneof response {
    bytes  result = 21;
    string error  = 22;
  }
}
